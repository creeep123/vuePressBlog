## 为什么要使用 this ？ 

this 可以避免显式地传递对象，取而代之的是一种更优雅的方式来隐式地“传递”一个对象引用，通过这种方式来将API设计得更加简洁并且易于复用。

## 对 this 存在的**误解**

​	**X**		this 指向自身			

​	**X**		this 指向它的作用域



## this 是什么？

- 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。

- 每个函数的this是在调用时被绑定的，完全取决于函数的**调用位置**



## 调用位置是什么？

- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）

- 定义很简单，但要找到实际情况中的函数调用位置，最重要的是分析**调用栈**
- 调用位置就在调用栈中**当前执行**函数的**前一个**调用中

下面我们来看看到底什么是**调用栈**和**调用位置**：

```javascript
function baz() {￼
    // 当前调用栈是：baz￼
    // 因此，当前调用位置是全局作用域￼
    ￼
    console.log("baz");￼
    bar(); // <-- bar的调用位置￼
}￼
￼
function bar() {
    ￼
    // 当前调用栈是baz -> bar￼
    // 因此，当前调用位置在baz中￼
    ￼
    console.log("bar");￼
    foo(); // <-- foo的调用位置￼
}￼
￼
function foo() {￼
    // 当前调用栈是baz -> bar -> foo￼
    // 因此，当前调用位置在bar中￼
    ￼
    console.log("foo");￼
}￼
               ￼
baz(); // <-- baz的调用位置
```

在实际编程中，可以使用浏览器的调试工具，其中包含了JavaScript调试器。

就本例来说，你可以在工具中给foo()函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条debugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析this的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。

实战：

![image-20200815214232759](https://gitee.com/yxon123/gitee-sources/raw/master//Images/20200815214931.png)

<img src="https://gitee.com/yxon123/gitee-sources/raw/master//Images/20200815214310.png" alt="image-20200815214310543" style="zoom:150%;" />

找到调用位置之后，this 的绑定还需要遵循一些规则，规则有如下四条：

1. 默认绑定
2. 隐式绑定
3. 显示绑定
4. new 绑定

当其中几条规则同时适用时，需要按照一个优先级来遵循优先级第一位的规则。



## 小结

- this 可以避免显示地传递对象，让代码简洁易复用。
- this 的绑定只和调用位置有关，且遵循一定的规则。
- 可以通过调用栈来找到调用位置。